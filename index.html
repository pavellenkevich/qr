<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QR Generator</title>
  <meta name="description" content="Minimal QR code generator: SVG / PNG / JPG with style options" />
  <meta name="theme-color" content="#f2f2f2" />
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="app">
    <header>
      <h1>
        <span>QR</span>
        <span>Generator</span>
        <span class="light">Reader</span>
        <span class="tag">Coming soon</span>
      </h1>
      <span class="scribble" aria-hidden="true"></span>
    </header>

    <div class="grid">
      <!-- LEFT -->
      <section class="left">
        <label class="title" for="data">Enter your text:</label>
        <input id="data" class="input" type="text" placeholder="https://" autocomplete="off" />

        <label class="title">Choose a style:</label>
        <div class="tabs" id="styleTabs" role="tablist" aria-label="Style">
          <button type="button" data-style="squares" class="active" role="tab" aria-selected="true">Squares</button>
          <button type="button" data-style="dots" role="tab" aria-selected="false">Circles</button>
          <button type="button" data-style="diamonds" role="tab" aria-selected="false">Rombs</button>
        </div>

        <label class="title">Shape color:</label>
        <div class="color-row">
          <input id="color" class="color-picker" type="color" value="#000000" />
          <input id="colorHex" class="hex-input" type="text" value="#000000" maxlength="7" placeholder="#000000" />
        </div>

        <label class="title">Background:</label>
        <div class="color-row">
          <input id="bgColor" class="color-picker" type="color" value="#FFFFFF" />
          <input id="bgColorHex" class="hex-input" type="text" value="#FFFFFF" maxlength="7" placeholder="#FFFFFF" />
        </div>
        <div class="checkbox-row">
          <input type="checkbox" id="transparentBg" />
          <label for="transparentBg">Transparent background</label>
        </div>

        <label class="title">File type:</label>
        <div class="chips" id="typeChips" role="tablist" aria-label="File type">
          <button type="button" data-type="svg" class="active" role="tab" aria-selected="true">SVG</button>
          <button type="button" data-type="png" role="tab" aria-selected="false">PNG</button>
          <button type="button" data-type="jpg" role="tab" aria-selected="false">JPG</button>
        </div>

        <div class="group" id="resolutionGroup">
          <label class="title">Resolution:</label>
          <div class="chips" id="resolutionChips" role="tablist" aria-label="Resolution">
            <button type="button" data-size="512" role="tab" aria-selected="false">512</button>
            <button type="button" data-size="1024" class="active" role="tab" aria-selected="true">1024</button>
            <button type="button" data-size="2048" role="tab" aria-selected="false">2048</button>
          </div>
        </div>

        <button class="btn secondary" id="dlBtn" disabled>Download</button>
      </section>

      <!-- RIGHT -->
      <section class="right">
        <div class="stage">
          <div class="paper" id="paper">
            <div class="placeholder">YOUR QR WILL BE HERE</div>
          </div>
        </div>
      </section>
    </div>

    <footer>
      Created by <a href="#" rel="noopener">Liankevich</a> / <a href="#" rel="noopener">Donate</a>
    </footer>
  </div>

  <!-- QR matrix lib -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcode-generator/1.4.4/qrcode.min.js"></script>

  <script>
    (() => {
    // Elements
      const $ = (s) => document.querySelector(s);
      const paper = $('#paper');
      const dataEl = $('#data');
      const dlBtn = $('#dlBtn');
      const colorEl = $('#color');
      const colorHexEl = $('#colorHex');
      const bgColorEl = $('#bgColor');
      const bgColorHexEl = $('#bgColorHex');
      const transparentBgEl = $('#transparentBg');
      const resolutionGroup = $('#resolutionGroup');
      const resolutionChips = $('#resolutionChips');

      // State
      let style = 'squares';
      let ftype = 'svg';
      let qrColor = '#000000';
      let bgColor = '#FFFFFF';
      let transparentBg = false;
      let resolution = 1024;

      const styleTabs = $('#styleTabs');
      const typeChips = $('#typeChips');

      function updateResolutionVisibility() {
        resolutionGroup.classList.toggle('hidden', ftype === 'svg');
      }

      function isValidHex(hex) {
        return /^#[0-9A-F]{6}$/i.test(hex);
      }

      // Color picker -> HEX input sync
      colorEl.addEventListener('input', (e) => {
        qrColor = e.target.value.toUpperCase();
        colorHexEl.value = qrColor;
        generateQR();
      });

      // HEX input -> Color picker sync
      colorHexEl.addEventListener('input', (e) => {
        let val = e.target.value;
        if (!val.startsWith('#')) val = '#' + val;
        if (isValidHex(val)) {
          qrColor = val.toUpperCase();
          colorEl.value = qrColor;
          generateQR();
        }
      });

      colorHexEl.addEventListener('blur', (e) => {
        let val = e.target.value;
        if (!val.startsWith('#')) val = '#' + val;
        if (!isValidHex(val)) {
          e.target.value = qrColor;
        } else {
          qrColor = val.toUpperCase();
          colorEl.value = qrColor;
          e.target.value = qrColor;
        }
      });

      // Background color picker -> HEX input sync
      bgColorEl.addEventListener('input', (e) => {
        bgColor = e.target.value.toUpperCase();
        bgColorHexEl.value = bgColor;
        generateQR();
      });

      // Background HEX input -> Color picker sync
      bgColorHexEl.addEventListener('input', (e) => {
        let val = e.target.value;
        if (!val.startsWith('#')) val = '#' + val;
        if (isValidHex(val)) {
          bgColor = val.toUpperCase();
          bgColorEl.value = bgColor;
          generateQR();
        }
      });

      bgColorHexEl.addEventListener('blur', (e) => {
        let val = e.target.value;
        if (!val.startsWith('#')) val = '#' + val;
        if (!isValidHex(val)) {
          e.target.value = bgColor;
        } else {
          bgColor = val.toUpperCase();
          bgColorEl.value = bgColor;
          e.target.value = bgColor;
        }
      });

      transparentBgEl.addEventListener('change', (e) => {
        transparentBg = e.target.checked;
        if (ftype === 'jpg' && transparentBg) {
          transparentBg = false;
          e.target.checked = false;
          alert('JPG format does not support transparency');
        }
        generateQR();
      });

      // Auto-generate function
      let generateTimeout = null;
      function generateQR() {
        const text = (dataEl.value || '').trim();
        if (!text) {
          paper.innerHTML = '<div class="placeholder">YOUR QR WILL BE HERE</div>';
          dlBtn.disabled = true;
          return;
        }
        if (typeof window.qrcode !== 'function') return;

        // Debounce generation
        clearTimeout(generateTimeout);
        generateTimeout = setTimeout(async () => {
          revoke();
          dlBtn.disabled = true;
          const qr = buildQR(text);
          if (ftype === 'svg') {
            const svg = renderSVG(qr);
            setPreview(svg);
            const blob = new Blob([new XMLSerializer().serializeToString(svg)], { type: 'image/svg+xml' });
            lastUrl = URL.createObjectURL(blob);
            lastFmt = 'svg';
      } else {
            const canvas = renderCanvas(qr, resolution);
            setPreview(canvas);
            const mime = ftype === 'jpg' ? 'image/jpeg' : 'image/png';
            lastUrl = await toBlobUrl(canvas, mime);
            lastFmt = ftype;
          }
          dlBtn.disabled = false;
        }, 300);
      }

      styleTabs.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-style]');
        if (!btn) return;
        styleTabs.querySelectorAll('button').forEach(b => {
          b.classList.remove('active');
          b.setAttribute('aria-selected', 'false');
        });
        btn.classList.add('active');
        btn.setAttribute('aria-selected', 'true');
        style = btn.dataset.style;
        generateQR();
      });

      typeChips.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-type]');
        if (!btn) return;
        typeChips.querySelectorAll('button').forEach(b => {
          b.classList.remove('active');
          b.setAttribute('aria-selected', 'false');
        });
        btn.classList.add('active');
        btn.setAttribute('aria-selected', 'true');
        ftype = btn.dataset.type;
        if (ftype === 'jpg' && transparentBg) {
          transparentBg = false;
          transparentBgEl.checked = false;
        }
        updateResolutionVisibility();
        generateQR();
      });

      resolutionChips.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-size]');
        if (!btn) return;
        resolutionChips.querySelectorAll('button').forEach(b => {
          b.classList.remove('active');
          b.setAttribute('aria-selected', 'false');
        });
        btn.classList.add('active');
        btn.setAttribute('aria-selected', 'true');
        resolution = parseInt(btn.dataset.size, 10);
        generateQR();
      });

      // Generate on text input change
      dataEl.addEventListener('input', generateQR);

      updateResolutionVisibility();

      let lastUrl = null;
      let lastFmt = null;
      let lastName = 'qr-code';

      function revoke() {
        if (lastUrl) {
          URL.revokeObjectURL(lastUrl);
          lastUrl = null;
        }
      }

      function buildQR(text) {
        const qr = window.qrcode(0, 'M');
        qr.addData(text);
        qr.make();
        return qr;
      }

      function renderCanvas(qr, targetSize) {
        const modules = qr.getModuleCount();
        const quiet = 4;
        const scale = Math.max(1, Math.floor(targetSize / (modules + 2 * quiet)));
        const size = scale * (modules + 2 * quiet);
        const c = document.createElement('canvas');
        c.width = size;
        c.height = size;
        const ctx = c.getContext('2d');

        // Background
        if (transparentBg && ftype !== 'jpg') {
          ctx.clearRect(0, 0, size, size);
        } else {
          ctx.fillStyle = bgColor;
          ctx.fillRect(0, 0, size, size);
        }

        // QR shapes
        ctx.fillStyle = qrColor;
        const off = scale * quiet;
        if (style === 'dots') {
          const r = Math.floor(scale * 0.5);
          for (let rIdx = 0; rIdx < modules; rIdx++) {
            for (let cIdx = 0; cIdx < modules; cIdx++) {
              if (qr.isDark(rIdx, cIdx)) {
                const cx = off + cIdx * scale + scale / 2;
                const cy = off + rIdx * scale + scale / 2;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.fill();
              }
            }
          }
        } else if (style === 'diamonds') {
          for (let rIdx = 0; rIdx < modules; rIdx++) {
            for (let cIdx = 0; cIdx < modules; cIdx++) {
              if (qr.isDark(rIdx, cIdx)) {
                const x = off + cIdx * scale;
                const y = off + rIdx * scale;
                ctx.save();
                ctx.translate(x + scale / 2, y + scale / 2);
                ctx.rotate(Math.PI / 4);
                ctx.fillRect(-scale / 2, -scale / 2, scale, scale);
                ctx.restore();
              }
            }
          }
        } else {
          for (let rIdx = 0; rIdx < modules; rIdx++) {
            for (let cIdx = 0; cIdx < modules; cIdx++) {
              if (qr.isDark(rIdx, cIdx)) {
                ctx.fillRect(off + cIdx * scale, off + rIdx * scale, scale, scale);
              }
            }
          }
        }
        return c;
      }

      function renderSVG(qr) {
        const modules = qr.getModuleCount();
        const quiet = 4;
        const cell = 8;
        const size = (modules + 2 * quiet) * cell;
        const xmlns = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(xmlns, 'svg');
        svg.setAttribute('viewBox', `0 0 ${size} ${size}`);
        svg.setAttribute('width', size);
        svg.setAttribute('height', size);

        // Background
        if (!transparentBg) {
          const bg = document.createElementNS(xmlns, 'rect');
          bg.setAttribute('fill', bgColor);
          bg.setAttribute('width', size);
          bg.setAttribute('height', size);
          svg.appendChild(bg);
        }

        const g = document.createElementNS(xmlns, 'g');
        g.setAttribute('fill', qrColor);
        svg.appendChild(g);
        const off = quiet * cell;
        for (let r = 0; r < modules; r++) {
          for (let c = 0; c < modules; c++) {
            if (qr.isDark(r, c)) {
              const x = off + c * cell;
              const y = off + r * cell;
              if (style === 'dots') {
                const circ = document.createElementNS(xmlns, 'circle');
                circ.setAttribute('cx', x + cell / 2);
                circ.setAttribute('cy', y + cell / 2);
                circ.setAttribute('r', Math.floor(cell * 0.5));
                g.appendChild(circ);
              } else if (style === 'diamonds') {
                const gg = document.createElementNS(xmlns, 'g');
                gg.setAttribute('transform', `translate(${x + cell / 2} ${y + cell / 2}) rotate(45) translate(${-cell / 2} ${-cell / 2})`);
                const rect = document.createElementNS(xmlns, 'rect');
                rect.setAttribute('width', cell);
                rect.setAttribute('height', cell);
                gg.appendChild(rect);
                g.appendChild(gg);
              } else {
                const rect = document.createElementNS(xmlns, 'rect');
                rect.setAttribute('x', x);
                rect.setAttribute('y', y);
                rect.setAttribute('width', cell);
                rect.setAttribute('height', cell);
                g.appendChild(rect);
              }
            }
          }
        }
        return svg;
      }

      function setPreview(node) {
        paper.innerHTML = '';
        paper.appendChild(node);
      }

      async function toBlobUrl(canvas, mime) {
        return new Promise((resolve) => {
          if (canvas.toBlob) {
            if (mime === 'image/png' && transparentBg) {
              canvas.toBlob(b => resolve(URL.createObjectURL(b)), mime, 1.0);
            } else {
              canvas.toBlob(b => resolve(URL.createObjectURL(b)), mime, 0.92);
            }
      } else {
            const quality = (mime === 'image/png' && transparentBg) ? 1.0 : 0.92;
            const dataUrl = canvas.toDataURL(mime, quality);
            fetch(dataUrl).then(r => r.blob()).then(b => resolve(URL.createObjectURL(b)));
          }
        });
      }

      dlBtn.addEventListener('click', () => {
        if (!lastUrl) return;
        const a = document.createElement('a');
        a.href = lastUrl;
        a.download = `qr-code.${lastFmt}`;
        document.body.appendChild(a);
        a.click();
        a.remove();
      });
    })();
  </script>
</body>
</html>
